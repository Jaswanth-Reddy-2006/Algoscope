[
  {
    "id": "data_structures",
    "title": "Data Structures",
    "description": "The atomic blocks of memory and logic.",
    "icon": "Database",
    "modules": [
      {
        "id": "arrays",
        "title": "Array",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "Contiguous memory blocks for O(1) access.",
        "definition": "A collection of items stored at contiguous memory locations.",
        "whatItIs": "The simplest data structure where elements are stored in contiguous memory locations, allowing for constant-time access via index.",
        "coreInvariant": "Index i is at address Base + (i * ElementSize).",
        "timeComplexity": [
          {
            "operation": "Access",
            "time": "O(1)",
            "space": "O(1)"
          },
          {
            "operation": "Insert",
            "time": "O(n)",
            "space": "O(1)"
          },
          {
            "operation": "Delete",
            "time": "O(n)",
            "space": "O(1)"
          },
          {
            "operation": "Search",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "array",
        "subPatterns": [],
        "recognitionSignals": [
          "Index access needed",
          "Fixed size collection",
          "Contiguous data"
        ],
        "formulaPattern": "arr[i]",
        "commonMistakes": [
          "Index out of bounds",
          "Off-by-one errors"
        ],
        "edgeCases": [
          "Empty array",
          "Index < 0",
          "Index >= length"
        ],
        "templates": {
          "python": "# Array Access\nvalue = arr[i]\n\n# Array Traversal\nfor x in arr:\n    print(x)",
          "javascript": "// Array Access\nconst value = arr[i];\n\n// Array Traversal\nfor (const x of arr) {\n    console.log(x);\n}"
        },
        "microDrills": [
          {
            "question": "What is the time complexity to access an element by index in an array?",
            "options": [
              "O(1)",
              "O(n)",
              "O(log n)",
              "O(n^2)"
            ],
            "correctAnswer": "O(1)"
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "strings",
        "title": "String",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "Immutable sequences of characters.",
        "definition": "A sequence of characters, often immutable in many languages.",
        "whatItIs": "A sequence of characters. In many modern languages (Java, Python, JS), strings are immutable, meaning they cannot be changed after creation.",
        "coreInvariant": "s[i] refers to the character at index i.",
        "timeComplexity": [
          {
            "operation": "Access",
            "time": "O(1)",
            "space": "O(1)"
          },
          {
            "operation": "Concatenation",
            "time": "O(n)",
            "space": "O(n)"
          },
          {
            "operation": "Substring",
            "time": "O(n)",
            "space": "O(n)"
          }
        ],
        "visualizerType": "string",
        "subPatterns": [],
        "recognitionSignals": [
          "Text processing",
          "Character manipulation",
          "Palindrome/Anagram"
        ],
        "formulaPattern": "s[i...j]",
        "commonMistakes": [
          "Assuming mutability in immutable languages",
          "String concatenation in loops (O(n^2))"
        ],
        "edgeCases": [
          "Empty string",
          "Single character",
          "Whitespace only"
        ],
        "templates": {
          "python": "# String Builders are efficient\nres = []\nres.append('c')\nfinal_str = ''.join(res)",
          "javascript": "// String Builders (Array join) are efficient\nconst res = [];\nres.push('c');\nconst finalStr = res.join('');"
        },
        "microDrills": [],
        "recognitionChallenges": []
      },
      {
        "id": "stacks",
        "title": "Stack",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "LIFO linear structure.",
        "definition": "Last-In-First-Out data structure.",
        "whatItIs": "A collection that follows LIFO (Last In, First Out). Think of a stack of plates.",
        "coreInvariant": "Last element added is the first one removed.",
        "timeComplexity": [
          {
            "operation": "Push",
            "time": "O(1)",
            "space": "O(1)"
          },
          {
            "operation": "Pop",
            "time": "O(1)",
            "space": "O(1)"
          },
          {
            "operation": "Peek",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "stack",
        "subPatterns": [],
        "recognitionSignals": [
          "LIFO requirements",
          "Undo/Redo",
          "Matching brackets",
          "Depth-First Search"
        ],
        "formulaPattern": "stack.pop()",
        "commonMistakes": [
          "Popping from empty stack",
          "Confusing LIFO with FIFO"
        ],
        "edgeCases": [
          "Empty stack pop",
          "Stack overflow (if fixed size)"
        ],
        "templates": {
          "python": "stack = []\nstack.append(x) # Push\nval = stack.pop() # Pop",
          "javascript": "const stack = [];\nstack.push(x); // Push\nconst val = stack.pop(); // Pop"
        },
        "microDrills": [],
        "recognitionChallenges": []
      },
      {
        "id": "queues",
        "title": "Queue",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "FIFO linear structure.",
        "definition": "First-In-First-Out data structure.",
        "whatItIs": "A collection that follows FIFO (First In, First Out). Think of a line at a store.",
        "coreInvariant": "First element added is the first one removed.",
        "timeComplexity": [
          {
            "operation": "Enqueue",
            "time": "O(1)",
            "space": "O(1)"
          },
          {
            "operation": "Dequeue",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "queue",
        "subPatterns": [],
        "recognitionSignals": [
          "FIFO requirements",
          "Order processing",
          "Breadth-First Search"
        ],
        "formulaPattern": "queue.dequeue()",
        "commonMistakes": [
          "Dequeuing empty queue",
          "Confusing FIFO with LIFO"
        ],
        "edgeCases": [
          "Empty queue dequeue"
        ],
        "templates": {
          "python": "from collections import deque\nq = deque()\nq.append(x) # Enqueue\nval = q.popleft() # Dequeue",
          "javascript": "const q = [];\nq.push(x); // Enqueue\nconst val = q.shift(); // Dequeue (O(n) in JS array, use Linked List for O(1))"
        },
        "microDrills": [],
        "recognitionChallenges": []
      },
      {
        "id": "hash_maps",
        "title": "Hash Map",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Key-value pairs with O(1) average access.",
        "definition": "A data structure that maps keys to values using a hash function.",
        "whatItIs": "A structure that maps keys to values for efficient lookup. Uses a hash function to compute an index into an array of buckets.",
        "coreInvariant": "Key maps to a consistent bucket index via Hash(Key) % Capacity.",
        "timeComplexity": [
          {
            "operation": "Insert",
            "time": "O(1)",
            "space": "O(n)"
          },
          {
            "operation": "Lookup",
            "time": "O(1)",
            "space": "O(n)"
          },
          {
            "operation": "Delete",
            "time": "O(1)",
            "space": "O(n)"
          }
        ],
        "visualizerType": "hash_map",
        "subPatterns": [],
        "recognitionSignals": [
          "Fast lookups needed",
          "Counting frequencies",
          "Finding duplicates"
        ],
        "formulaPattern": "map.get(key)",
        "commonMistakes": [
          "Ignoring collisions",
          "Using mutable keys"
        ],
        "edgeCases": [
          "Hash collisions",
          "Load factor resizing"
        ],
        "templates": {
          "python": "m = {}\nm[key] = val\nif key in m:\n    print(m[key])",
          "javascript": "const m = new Map();\nm.set(key, val);\nif (m.has(key)) {\n    console.log(m.get(key));\n}"
        },
        "microDrills": [],
        "recognitionChallenges": []
      },
      {
        "id": "linked_lists",
        "title": "Linked List",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "Nodes coupled by pointers.",
        "definition": "A linear collection of data elements whose order is not given by their physical placement in memory.",
        "whatItIs": "A sequence of nodes where each node points to the next node.",
        "coreInvariant": "Node.next points to the successor.",
        "timeComplexity": [
          {
            "operation": "Access",
            "time": "O(n)",
            "space": "O(1)"
          },
          {
            "operation": "Insert Head",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "linked_list",
        "subPatterns": [],
        "recognitionSignals": [
          "Dynamic size",
          "Frequent insertions/deletions at ends"
        ],
        "formulaPattern": "curr = curr.next",
        "commonMistakes": [
          "Lost reference (memory leak)",
          "Null pointer exception"
        ],
        "edgeCases": [
          "Empty list",
          "Single node",
          "Cycle detection"
        ],
        "templates": {
          "python": "class Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
          "javascript": "class Node {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}"
        },
        "microDrills": [],
        "recognitionChallenges": []
      },
      {
        "id": "heaps",
        "title": "Heap / Priority Queue",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Tree-based structure for efficient max/min access.",
        "definition": "A specialized tree-based data structure which is essentially an almost complete tree that satisfies the heap property.",
        "whatItIs": "A binary tree that satisfies the heap property (Parent >= Child for MaxHeap). Efficiently retrieves the min or max element.",
        "coreInvariant": "Parent is always >= (MaxHeap) or <= (MinHeap) than children.",
        "timeComplexity": [
          {
            "operation": "Insert",
            "time": "O(log n)",
            "space": "O(n)"
          },
          {
            "operation": "Extract Max",
            "time": "O(log n)",
            "space": "O(n)"
          },
          {
            "operation": "Peek",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "heap",
        "subPatterns": [],
        "recognitionSignals": [
          "Kth largest/smallest",
          "Median of stream",
          "Task scheduling"
        ],
        "formulaPattern": "heapq.heappush(h, val)",
        "commonMistakes": [
          "Confusing MinHeap (default in Python) with MaxHeap"
        ],
        "edgeCases": [
          "Empty heap extract"
        ],
        "templates": {
          "python": "import heapq\nh = []\nheapq.heappush(h, val)\nmin_val = heapq.heappop(h)",
          "javascript": "// JS has no built-in Heap, usually requires custom class or library."
        },
        "microDrills": [],
        "recognitionChallenges": []
      },
      {
        "id": "matrices",
        "title": "Matrix (2D Arrays)",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Grid-based data representation.",
        "definition": "A two-dimensional array representing table-like data.",
        "whatItIs": "A 2D array representing a grid or table.",
        "coreInvariant": "matrix[r][c] is the cell at row r, column c.",
        "timeComplexity": [
          {
            "operation": "Access",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "matrix",
        "subPatterns": [],
        "recognitionSignals": [
          "Grid traversal",
          "Game boards",
          "Image processing"
        ],
        "formulaPattern": "matrix[row][col]",
        "commonMistakes": [
          "Confusing row (y) and col (x) indices"
        ],
        "edgeCases": [
          "Empty matrix",
          "Jagged matrix (uneven rows)"
        ],
        "templates": {
          "python": "rows, cols = len(matrix), len(matrix[0])\nfor r in range(rows):\n    for c in range(cols):\n        print(matrix[r][c])",
          "javascript": "for(let r=0; r<matrix.length; r++) {\n    for(let c=0; c<matrix[0].length; c++) {\n        console.log(matrix[r][c]);\n    }\n}"
        },
        "microDrills": [],
        "recognitionChallenges": []
      },
      {
        "id": "prefix_sums",
        "title": "Prefix Sum Arrays",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Precomputed cumulative sums for range queries.",
        "definition": "An array where the element at index i stores the sum of the original array from 0 to i.",
        "whatItIs": "An auxiliary array where P[i] stores the sum of A[0...i]. Allows O(1) range sum queries.",
        "coreInvariant": "Sum(i, j) = P[j] - P[i-1]",
        "timeComplexity": [
          {
            "operation": "Build",
            "time": "O(n)",
            "space": "O(n)"
          },
          {
            "operation": "Range Query",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "prefix_sum",
        "subPatterns": [],
        "recognitionSignals": [
          "Range sum queries",
          "Constant time subarray sum"
        ],
        "formulaPattern": "P[i] = P[i-1] + A[i]",
        "commonMistakes": [
          "Off-by-one error in range formula"
        ],
        "edgeCases": [
          "Empty array",
          "i=0 case (needs P[-1] handling)"
        ],
        "templates": {
          "python": "P = [0] * (len(nums) + 1)\nfor i, x in enumerate(nums):\n    P[i+1] = P[i] + x\n# Sum(i, j) = P[j+1] - P[i]",
          "javascript": "const P = new Array(nums.length + 1).fill(0);\nfor(let i=0; i<nums.length; i++) {\n    P[i+1] = P[i] + nums[i];\n}"
        },
        "microDrills": [],
        "recognitionChallenges": []
      },
      {
        "id": "bit_manipulation",
        "title": "Bit Manipulation",
        "family": "Data Structures",
        "difficulty": "Expert",
        "description": "Low-level binary operations.",
        "definition": "Direct manipulation of bits to perform operations efficiently.",
        "whatItIs": "Operating on data at the bit level (AND, OR, XOR, Shifts).",
        "coreInvariant": "Information is encoded in binary bits.",
        "timeComplexity": [
          {
            "operation": "Bitwise Ops",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "bit_manipulation",
        "subPatterns": [],
        "recognitionSignals": [
          "Binary representation",
          "Space optimization",
          "XOR tricks"
        ],
        "formulaPattern": "x & (x-1)",
        "commonMistakes": [
          "Operator precedence",
          "Signed vs Unsigned shifts"
        ],
        "edgeCases": [
          "Overflow",
          "Negative numbers (Two's complement)"
        ],
        "templates": {
          "python": "# Check if kth bit is set\nis_set = (n >> k) & 1",
          "javascript": "// Check if kth bit is set\nconst isSet = (n >> k) & 1;"
        },
        "microDrills": [],
        "recognitionChallenges": []
      }
    ]
  },
  {
    "id": "core_patterns",
    "title": "Core Patterns",
    "description": "Standard solutions to recurring computational problems.",
    "icon": "Layers",
    "modules": [
      {
        "id": "two_pointers",
        "title": "Two Pointers",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Traverse data from different directions or at different speeds to optimize search.",
        "definition": "A technique using two synchronized indices to traverse a data structure efficiently.",
        "mentalModel": {
          "analogy": "The Dual Scanners",
          "analogyImage": "two_pointers_analogy",
          "realWorldExample": "Two workers scanning a line from both ends to meet in the middle (e.g., matching sorted list items).",
          "coreInsight": "Narrowing the search space! Instead of checking every pair with nested loops O(N²), we use two pointers to eliminate large portions of the search space in each step O(N).",
          "problemStatement": {
            "definition": "Find two elements in a sorted array that sum up to a specific target value.",
            "returnValue": "The indices of the two elements.",
            "constraints": [
              "Input array is sorted",
              "Constant extra space O(1)",
              "Linear time complexity O(N)"
            ]
          },
          "efficiencyComparison": {
            "bruteForce": "O(N²)",
            "optimal": "O(N)",
            "gain": "95%"
          }
        },
        "whatItIs": "Using two pointers to iterate through a data structure, typically in sorted arrays or linked lists, to find elements satisfying a condition.",
        "coreInvariant": "Pointers maintain a relationship (e.g., L < R) that defines the valid search space, which shrinks monotonically.",
        "timeComplexity": [
          {
            "operation": "Single Pass Traversal",
            "time": "O(N)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "two_pointer",
        "subPatterns": [
          {
            "id": "opposite_direction",
            "title": "Opposite Direction (Convergence)",
            "description": "Pointers start at both ends and move towards each other.",
            "signals": [
              "Sorted array",
              "Find pair with target sum",
              "Search space shrinking"
            ],
            "invariant": "left < right",
            "formula": "if (sum < target) left++ else right--",
            "mistakes": [
              "Using on unsorted input without sorting first",
              "Incorrect loop condition (left <= right can cause overlap)",
              "Moving both pointers unnecessarily"
            ],
            "edgeCases": [
              {
                "title": "No pair exists",
                "description": "No two numbers sum up to the target.",
                "whyItBreaks": "Loop naturally finishes without return.",
                "howToFix": "Return a default indicator (e.g., [-1, -1]) after the loop."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "Why must the array be sorted for the Two Pointers approach to work in O(N)?",
                "options": [
                  "To use binary search",
                  "To allow predictable pointer movement (sum > target -> decrease sum)",
                  "Sorting is not required",
                  "To avoid duplicates"
                ],
                "correctAnswer": "To allow predictable pointer movement (sum > target -> decrease sum)",
                "explanation": "If the array is unsorted, we cannot know whether moving left or right will increase or decrease the sum.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def two_sum_brute(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return [-1, -1]",
                "optimal": "def two_sum_optimal(nums, target):\n    # Assumes nums is sorted\n    l, r = 0, len(nums) - 1\n    while l < r:\n        s = nums[l] + nums[r]\n        if s == target: return [l, r]\n        if s < target: l += 1\n        else: r -= 1\n    return [-1, -1]"
              },
              "javascript": {
                "bruteForce": "function twoSumBrute(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] === target) return [i, j];\n        }\n    }\n    return [-1, -1];\n}",
                "optimal": "function twoSumOptimal(nums, target) {\n    // Assumes nums is sorted\n    let l = 0, r = nums.length - 1;\n    while (l < r) {\n        const s = nums[l] + nums[r];\n        if (s === target) return [l, r];\n        s < target ? l++ : r--;\n    }\n    return [-1, -1];\n}"
              },
              "java": {
                "bruteForce": "public int[] twoSumBrute(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == target) return new int[]{i, j};\n        }\n    }\n    return new int[]{-1, -1};\n}",
                "optimal": "public int[] twoSumOptimal(int[] nums, int target) {\n    int l = 0, r = nums.length - 1;\n    while (l < r) {\n        int s = nums[l] + nums[r];\n        if (s == target) return new int[]{l, r};\n        if (s < target) l++; else r--;\n    }\n    return new int[]{-1, -1};\n}"
              },
              "cpp": {
                "bruteForce": "vector<int> twoSumBrute(vector<int>& nums, int target) {\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[i] + nums[j] == target) return {i, j};\n        }\n    }\n    return {-1, -1};\n}",
                "optimal": "vector<int> twoSumOptimal(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1;\n    while (l < r) {\n        int s = nums[l] + nums[r];\n        if (s == target) return {l, r};\n        if (s < target) l++; else r--;\n    }\n    return {-1, -1};\n}"
              }
            }
          },
          {
            "id": "same_direction",
            "title": "Same Direction (Compaction)",
            "description": "Both pointers move in the same direction, usually at different speeds or conditions.",
            "signals": [
              "In-place removal",
              "Deduplication",
              "Fast scanner with slow writer"
            ],
            "invariant": "slow pointer <= fast pointer",
            "formula": "if (keep) { arr[slow] = arr[fast]; slow++; }",
            "mistakes": [
              "Incorrectly incrementing slow pointer before assignment",
              "Not processing the last element",
              "Boundary check skipping the first element"
            ],
            "edgeCases": [
              {
                "title": "Empty / Single Element",
                "description": "Input has 0 or 1 element.",
                "whyItBreaks": "Pointers might index out of bounds if not checked.",
                "howToFix": "Return length immediately if len < 2."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Remove Duplicates', when does the slow pointer move?",
                "options": [
                  "Always",
                  "When fast pointer sees a unique element",
                  "When fast pointer sees a duplicate",
                  "Only at the end"
                ],
                "correctAnswer": "When fast pointer sees a unique element",
                "explanation": "We only advance 'slow' (our barrier for unique elements) when we find a NEW unique element at 'fast'.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def remove_duplicates_brute(nums):\n    unique = []\n    for x in nums:\n        if not unique or x != unique[-1]:\n            unique.append(x)\n    for i in range(len(unique)):\n        nums[i] = unique[i]\n    return len(unique)",
                "optimal": "def remove_duplicates_optimal(nums):\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1"
              },
              "javascript": {
                "bruteForce": "function removeDuplicatesBrute(nums) {\n    let unique = [];\n    for (let x of nums) {\n        if (unique.length === 0 || x !== unique[unique.length - 1]) unique.push(x);\n    }\n    for (let i = 0; i < unique.length; i++) nums[i] = unique[i];\n    return unique.length;\n}",
                "optimal": "function removeDuplicatesOptimal(nums) {\n    if (nums.length === 0) return 0;\n    let slow = 0;\n    for (let fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] !== nums[slow]) {\n            nums[++slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n}"
              },
              "java": {
                "bruteForce": "public int removeDuplicatesBrute(int[] nums) {\n    List<Integer> unique = new ArrayList<>();\n    for (int x : nums) {\n        if (unique.isEmpty() || x != unique.get(unique.size() - 1)) unique.add(x);\n    }\n    for (int i = 0; i < unique.size(); i++) nums[i] = unique.get(i);\n    return unique.size();\n}",
                "optimal": "public int removeDuplicatesOptimal(int[] nums) {\n    if (nums.length == 0) return 0;\n    int slow = 0;\n    for (int fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] != nums[slow]) {\n            nums[++slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n}"
              },
              "cpp": {
                "bruteForce": "int removeDuplicatesBrute(vector<int>& nums) {\n    vector<int> unique;\n    for (int x : nums) {\n        if (unique.empty() || x != unique.back()) unique.push_back(x);\n    }\n    for (int i = 0; i < unique.size(); i++) nums[i] = unique[i];\n    return unique.size();\n}",
                "optimal": "int removeDuplicatesOptimal(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int slow = 0;\n    for (int fast = 1; fast < nums.size(); fast++) {\n        if (nums[fast] != nums[slow]) {\n            nums[++slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n}"
              }
            }
          },
          {
            "id": "fast_slow",
            "title": "Fast & Slow (Cycle Detection)",
            "description": "One pointer moves twice as fast as the other to detect loops.",
            "signals": [
              "Linked List cycles",
              "Finding middle of structure",
              "Happy number sequence"
            ],
            "invariant": "distance(slow) = X, distance(fast) = 2X",
            "formula": "slow = slow.next; fast = fast.next.next;",
            "mistakes": [
              "Not checking fast.next before moving fast.next.next",
              "Starting both at the same position and immediately breaking the loop",
              "Incorrect termination for odd/even structures"
            ],
            "edgeCases": [
              {
                "title": "Single Node",
                "description": "List has only one node.",
                "whyItBreaks": "fast.next.next might throw error if not careful.",
                "howToFix": "Check if head is null or head.next is null."
              }
            ],
            "drills": [
              {
                "type": "complexity",
                "question": "What is the space complexity of Floyd's Cycle Finding Algorithm?",
                "options": [
                  "O(N)",
                  "O(log N)",
                  "O(1)",
                  "O(N^2)"
                ],
                "correctAnswer": "O(1)",
                "explanation": "It only uses two pointers regardless of the list size.",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def has_cycle_brute(head):\n    visited = set()\n    curr = head\n    while curr:\n        if curr in visited: return True\n        visited.add(curr)\n        curr = curr.next\n    return False",
                "optimal": "def has_cycle_optimal(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast: return True\n    return False"
              },
              "javascript": {
                "bruteForce": "function hasCycleBrute(head) {\n    let visited = new Set();\n    let curr = head;\n    while (curr) {\n        if (visited.has(curr)) return true;\n        visited.add(curr);\n        curr = curr.next;\n    }\n    return false;\n}",
                "optimal": "function hasCycleOptimal(head) {\n    let slow = head, fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) return true;\n    }\n    return false;\n}"
              },
              "java": {
                "bruteForce": "public boolean hasCycleBrute(ListNode head) {\n    Set<ListNode> visited = new HashSet<>();\n    ListNode curr = head;\n    while (curr != null) {\n        if (visited.contains(curr)) return true;\n        visited.add(curr);\n        curr = curr.next;\n    }\n    return false;\n}",
                "optimal": "public boolean hasCycleOptimal(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}"
              },
              "cpp": {
                "bruteForce": "bool hasCycleBrute(ListNode *head) {\n    unordered_set<ListNode*> visited;\n    ListNode *curr = head;\n    while (curr) {\n        if (visited.count(curr)) return true;\n        visited.insert(curr);\n        curr = curr->next;\n    }\n    return false;\n}",
                "optimal": "bool hasCycleOptimal(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}"
              }
            }
          },
          {
            "id": "partition_pattern",
            "title": "Partition (Three-Way)",
            "description": "Divide elements into three categories (Dutch National Flag).",
            "signals": [
              "0, 1, 2 sorting",
              "Pivot partitioning",
              "In-place categorization"
            ],
            "invariant": "0s < L, 1s [L...M], 2s > R",
            "formula": "swap(nums[m], nums[l]) if nums[m] == 0",
            "mistakes": [
              "Incrementing Mid after swapping with Right (Mid must re-check the swapped element)",
              "Incorrect boundary overlaps",
              "Off-by-one in the r initialization"
            ],
            "edgeCases": [
              {
                "title": "All same elements",
                "description": "Array contains only 0s, 1s, or 2s.",
                "whyItBreaks": "Boundaries might cross if not handled.",
                "howToFix": "Standard logic works, but l/r/m logic must be robust."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 3-way partition (Dutch National Flag), when we swap Mid (1) with Right (2), what pointers move?",
                "options": [
                  "Mid and Right",
                  "Only Right",
                  "Only Mid",
                  "Left and Mid"
                ],
                "correctAnswer": "Only Right",
                "explanation": "We decrement Right because we placed a known 2 there. We do NOT increment Mid because the element swapped from Right is unknown.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def sort_colors_brute(nums):\n    # Sort or count sort\n    c0 = c1 = c2 = 0\n    for n in nums:\n        if n == 0: c0 += 1\n        elif n == 1: c1 += 1\n        else: c2 += 1\n    for i in range(len(nums)):\n        if i < c0: nums[i] = 0\n        elif i < c0 + c1: nums[i] = 1\n        else: nums[i] = 2",
                "optimal": "def sort_colors_optimal(nums):\n    l, m, r = 0, 0, len(nums) - 1\n    while m <= r:\n        if nums[m] == 0:\n            nums[l], nums[m] = nums[m], nums[l]\n            l += 1; m += 1\n        elif nums[m] == 1: m += 1\n        else:\n            nums[m], nums[r] = nums[r], nums[m]\n            r -= 1"
              },
              "javascript": {
                "bruteForce": "function sortColorsBrute(nums) {\n    let c0 = 0, c1 = 0, c2 = 0;\n    for (let n of nums) {\n        if (n === 0) c0++; else if (n === 1) c1++; else c2++;\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (i < c0) nums[i] = 0;\n        else if (i < c0 + c1) nums[i] = 1;\n        else nums[i] = 2;\n    }\n}",
                "optimal": "function sortColorsOptimal(nums) {\n    let l = 0, m = 0, r = nums.length - 1;\n    while (m <= r) {\n        if (nums[m] === 0) [nums[l], nums[m]] = [nums[m++], nums[l++]];\n        else if (nums[m] === 1) m++;\n        else [nums[m], nums[r]] = [nums[r--], nums[m]];\n    }\n}"
              },
              "java": {
                "bruteForce": "public void sortColorsBrute(int[] nums) {\n    int c0 = 0, c1 = 0, c2 = 0;\n    for (int n : nums) {\n        if (n == 0) c0++; else if (n == 1) c1++; else c2++;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        if (i < c0) nums[i] = 0;\n        else if (i < c0 + c1) nums[i] = 1;\n        else nums[i] = 2;\n    }\n}",
                "optimal": "public void sortColorsOptimal(int[] nums) {\n    int l = 0, m = 0, r = nums.length - 1;\n    while (m <= r) {\n        if (nums[m] == 0) {\n            int t = nums[l]; nums[l++] = nums[m]; nums[m++] = t;\n        } else if (nums[m] == 1) m++;\n        else {\n            int t = nums[m]; nums[m] = nums[r]; nums[r--] = t;\n        }\n    }\n}"
              },
              "cpp": {
                "bruteForce": "void sortColorsBrute(vector<int>& nums) {\n    int c0 = 0, c1 = 0, c2 = 0;\n    for (int n : nums) {\n        if (n == 0) c0++; else if (n == 1) c1++; else c2++;\n    }\n    for (int i = 0; i < nums.size(); i++) {\n        if (i < c0) nums[i] = 0;\n        else if (i < c0 + c1) nums[i] = 1;\n        else nums[i] = 2;\n    }\n}",
                "optimal": "void sortColorsOptimal(vector<int>& nums) {\n    int l = 0, m = 0, r = nums.size() - 1;\n    while (m <= r) {\n        if (nums[m] == 0) swap(nums[l++], nums[m++]);\n        else if (nums[m] == 1) m++;\n        else swap(nums[m], nums[r--]);\n    }\n}"
              }
            }
          },
          {
            "id": "k_sum_gen",
            "title": "K-Sum Generalization",
            "description": "Anchor pointer with two-pointer search inside a loop for 3Sum, 4Sum, etc.",
            "signals": [
              "3Sum = 0",
              "Target sum of 3+ elements",
              "Deduplicating multiple pointers"
            ],
            "invariant": "Fix i, then solve TwoSum for [i+1, n-1].",
            "formula": "for i: TwoPointer(i+1, n-1)",
            "mistakes": [
              "Not sorting the array first (essential for two-pointer phase)",
              "Failing to skip duplicates for the anchor element i",
              "Attempting N\u00b3 brute force for N\u00b2 problem"
            ],
            "edgeCases": [
              {
                "title": "Fewer than 3 elements",
                "description": "Input array has length < 3",
                "whyItBreaks": "Loops won't execute, but must return empty list.",
                "howToFix": "Constraint check at start."
              },
              {
                "title": "No solution",
                "description": "No triplet sums to target.",
                "whyItBreaks": "Result remains empty.",
                "howToFix": "Correctly return empty list."
              }
            ],
            "drills": [
              {
                "type": "complexity",
                "question": "What is the time complexity of the optimal 3Sum solution?",
                "options": [
                  "O(N)",
                  "O(N log N)",
                  "O(N^2)",
                  "O(N^3)"
                ],
                "correctAnswer": "O(N^2)",
                "explanation": "Sorting takes O(N log N). The nested loop structure (anchor + 2-pointer sweep) takes O(N^2).",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def three_sum_brute(nums):\n    res = set()\n    nums.sort()  # Output requires sorted to deduce duplicates easily or use set\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    res.add((nums[i], nums[j], nums[k]))\n    return [list(x) for x in res]",
                "optimal": "def three_sum_optimal(nums):\n    nums.sort(); res = []\n    for i in range(len(nums)-2):\n        if i > 0 and nums[i] == nums[i-1]: continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0: l += 1\n            elif s > 0: r -= 1\n            else:\n                res.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l+1]: l += 1\n                while l < r and nums[r] == nums[r-1]: r -= 1\n                l += 1; r -= 1\n    return res"
              },
              "javascript": {
                "bruteForce": "function threeSumBrute(nums) {\n    nums.sort((a,b)=>a-b);\n    let res = [], n = nums.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (nums[i] + nums[j] + nums[k] === 0) {\n                    // naive duplicate check is hard, usually rely on Set of strings\n                    const trip = JSON.stringify([nums[i], nums[j], nums[k]]);\n                    if (!res.includes(trip)) res.push(trip);\n                }\n            }\n        }\n    }\n    return res.map(JSON.parse);\n}",
                "optimal": "function threeSumOptimal(nums) {\n    nums.sort((a,b) => a-b); const res = [];\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] === nums[i-1]) continue;\n        let l = i + 1, r = nums.length - 1;\n        while (l < r) {\n            const s = nums[i] + nums[l] + nums[r];\n            if (s === 0) {\n                res.push([nums[i], nums[l], nums[r]]);\n                while (l < r && nums[l] === nums[l+1]) l++;\n                while (l < r && nums[r] === nums[r-1]) r--;\n                l++; r--;\n            } else if (s < 0) l++; else r--;\n        }\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public List<List<Integer>> threeSumBrute(int[] nums) {\n    Arrays.sort(nums);\n    Set<List<Integer>> res = new HashSet<>();\n    int n = nums.length;\n    for (int i = 0; i < n; i++)\n        for (int j = i+1; j < n; j++)\n            for (int k = j+1; k < n; k++)\n                if (nums[i] + nums[j] + nums[k] == 0)\n                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));\n    return new ArrayList<>(res);\n}",
                "optimal": "public List<List<Integer>> threeSumOptimal(int[] nums) {\n    Arrays.sort(nums); List<List<Integer>> res = new ArrayList<>();\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] == nums[i-1]) continue;\n        int l = i + 1, r = nums.length - 1;\n        while (l < r) {\n            int s = nums[i] + nums[l] + nums[r];\n            if (s == 0) {\n                res.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                while (l < r && nums[l] == nums[l+1]) l++;\n                while (l < r && nums[r] == nums[r-1]) r--;\n                l++; r--;\n            } else if (s < 0) l++; else r--;\n        }\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "vector<vector<int>> threeSumBrute(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    set<vector<int>> s;\n    int n = nums.size();\n    for(int i=0; i<n; i++)\n        for(int j=i+1; j<n; j++)\n            for(int k=j+1; k<n; k++)\n                if(nums[i]+nums[j]+nums[k] == 0) s.insert({nums[i], nums[j], nums[k]});\n    return vector<vector<int>>(s.begin(), s.end());\n}",
                "optimal": "vector<vector<int>> threeSumOptimal(vector<int>& nums) {\n    sort(nums.begin(), nums.end()); vector<vector<int>> res;\n    for (int i = 0; i < (int)nums.size() - 2; i++) {\n        if (i > 0 && nums[i] == nums[i-1]) continue;\n        int l = i + 1, r = nums.size() - 1;\n        while (l < r) {\n            int s = nums[i] + nums[l] + nums[r];\n            if (s == 0) {\n                res.push_back({nums[i], nums[l], nums[r]});\n                while (l < r && nums[l] == nums[l+1]) l++;\n                while (l < r && nums[r] == nums[r-1]) r--;\n                l++; r--;\n            } else if (s < 0) l++; else r--;\n        }\n    }\n    return res;\n}"
              }
            }
          },
          {
            "id": "in_place_swap",
            "title": "In-Place Swapping",
            "description": "Swap elements between pointers to reorder the array.",
            "signals": [
              "Reverse string/array",
              "Move zeros to end",
              "Zero-space cost requirement"
            ],
            "invariant": "Elements outside the pointers are processed.",
            "formula": "swap(arr[l], arr[r]); l++; r--;",
            "templates": {
              "python": {
                "bruteForce": "def reverse_string_brute(s):\n    return s[::-1] # New list creation",
                "optimal": "def reverse_string_optimal(s):\n    l, r = 0, len(s) - 1\n    while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1; r -= 1"
              },
              "javascript": {
                "bruteForce": "function reverseStringBrute(s) {\n    return s.slice().reverse(); // Creates copy\n}",
                "optimal": "function reverseStringOptimal(s) {\n    let l = 0, r = s.length - 1;\n    while (l < r) {\n        [s[l], s[r]] = [s[r], s[l]];\n        l++; r--;\n    }\n}"
              },
              "java": {
                "bruteForce": "public void reverseStringBrute(char[] s) {\n    // Java strings immutable, must use StringBuilder or new array for 'copy' logic\n    char[] copy = new char[s.length];\n    for(int i=0; i<s.length; i++) copy[i] = s[s.length-1-i];\n    System.arraycopy(copy, 0, s, 0, s.length);\n}",
                "optimal": "public void reverseStringOptimal(char[] s) {\n    int l = 0, r = s.length - 1;\n    while (l < r) {\n        char t = s[l]; s[l++] = s[r]; s[r--] = t;\n    }\n}"
              },
              "cpp": {
                "bruteForce": "void reverseStringBrute(vector<char>& s) {\n    reverse(s.begin(), s.end()); // STL optimized, typically equivalent to optimal logic users write manually\n}",
                "optimal": "void reverseStringOptimal(vector<char>& s) {\n    int l = 0, r = s.size() - 1;\n    while (l < r) swap(s[l++], s[r--]);\n}"
              }
            },
            "edgeCases": [
              {
                "title": "Empty String",
                "description": "Input has 0 length.",
                "whyItBreaks": "Accessing s[0] causes error.",
                "howToFix": "Constraint checks or loop condition (0 < -1) handles it naturally."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Reverse String', when do we stop swapping?",
                "options": [
                  "When Left == Right",
                  "When Left < Right",
                  "When Left > Right",
                  "When Left >= Right"
                ],
                "correctAnswer": "When Left >= Right",
                "explanation": "If Left == Right, the middle element doesn't need swapping. If Left > Right, we've crossed.",
                "category": "movement"
              }
            ]
          },
          {
            "id": "merge_sorted",
            "title": "Merge Two Sorted",
            "description": "Scan two arrays and build a third (or merger in-place from end).",
            "signals": [
              "Sorted input strings/arrays merging",
              "Merging linked lists",
              "Combining datasets"
            ],
            "invariant": "Smallest element of remaining is always at current pointers.",
            "formula": "if (a[i] < b[j]) add a[i++] else add b[j++]",
            "templates": {
              "python": {
                "bruteForce": "def merge_brute(nums1, m, nums2, n):\n    # Copy nums2 to end of nums1 then sort\n    for i in range(n):\n        nums1[m+i] = nums2[i]\n    nums1.sort()",
                "optimal": "def merge_optimal(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]; i -= 1\n        else:\n            nums1[k] = nums2[j]; j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]; j -= 1; k -= 1"
              },
              "javascript": {
                "bruteForce": "function mergeBrute(nums1, m, nums2, n) {\n    for (let i = 0; i < n; i++) nums1[m + i] = nums2[i];\n    nums1.sort((a,b)=>a-b);\n}",
                "optimal": "function mergeOptimal(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n    }\n    while (j >= 0) nums1[k--] = nums2[j--];\n}"
              },
              "java": {
                "bruteForce": "public void mergeBrute(int[] nums1, int m, int[] nums2, int n) {\n    for (int i = 0; i < n; i++) nums1[m + i] = nums2[i];\n    Arrays.sort(nums1);\n}",
                "optimal": "public void mergeOptimal(int[] nums1, int m, int[] nums2, int n) {\n    int i = m-1, j = n-1, k = m+n-1;\n    while (i >= 0 && j >= 0) {\n        nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];\n    }\n    while (j >= 0) nums1[k--] = nums2[j--];\n}"
              },
              "cpp": {
                "bruteForce": "void mergeBrute(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    for (int i = 0; i < n; i++) nums1[m + i] = nums2[i];\n    sort(nums1.begin(), nums1.end());\n}",
                "optimal": "void mergeOptimal(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];\n    }\n    while (j >= 0) nums1[k--] = nums2[j--];\n}"
              }
            },
            "edgeCases": [
              {
                "title": "One array empty",
                "description": "m=0 or n=0.",
                "whyItBreaks": "Loops might not execute.",
                "howToFix": "The cleanup loop `while (j >= 0)` handles the n > 0 case when m=0 naturally."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "Why do we merge from the END of the arrays when merging nums2 into nums1 in-place?",
                "options": [
                  "To avoid overwriting elements in nums1 that haven't been moved yet",
                  "It's faster",
                  "Because arrays are stored in reverse",
                  "To follow the Two Pointers pattern"
                ],
                "correctAnswer": "To avoid overwriting elements in nums1 that haven't been moved yet",
                "explanation": "If we started from the front, we might overwrite a value in nums1[0] that is needed later.",
                "category": "invariant"
              }
            ]
          },
          {
            "id": "palindrome_comp",
            "title": "Palindrome Comparison",
            "description": "Check if start and end characters are equal while moving inward.",
            "signals": [
              "Is Palindrome?",
              "Symmetry check",
              "String validation"
            ],
            "invariant": "s[l] == s[r] for all active l, r.",
            "formula": "if (s[l] != s[r]) return false",
            "templates": {
              "python": {
                "bruteForce": "def is_palindrome_brute(s):\n    filtered = [c.lower() for c in s if c.isalnum()]\n    return filtered == filtered[::-1]",
                "optimal": "def is_palindrome_optimal(s):\n    l, r = 0, len(s) - 1\n    while l < r:\n        if not s[l].isalnum(): l += 1\n        elif not s[r].isalnum(): r -= 1\n        elif s[l].lower() != s[r].lower(): return False\n        else: l += 1; r -= 1\n    return True"
              },
              "javascript": {
                "bruteForce": "function isPalindromeBrute(s) {\n    const clean = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    return clean === clean.split('').reverse().join('');\n}",
                "optimal": "function isPalindromeOptimal(s) {\n    let l = 0, r = s.length - 1;\n    while (l < r) {\n        if (!/[a-z0-9]/i.test(s[l])) l++;\n        else if (!/[a-z0-9]/i.test(s[r])) r--;\n        else if (s[l++].toLowerCase() !== s[r--].toLowerCase()) return false;\n    }\n    return true;\n}"
              },
              "java": {
                "bruteForce": "public boolean isPalindromeBrute(String s) {\n    StringBuilder sb = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) sb.append(Character.toLowerCase(c));\n    }\n    return sb.toString().equals(sb.reverse().toString());\n}",
                "optimal": "public boolean isPalindromeOptimal(String s) {\n    int l = 0, r = s.length() - 1;\n    while (l < r) {\n        char currL = s.charAt(l), currR = s.charAt(r);\n        if (!Character.isLetterOrDigit(currL)) l++;\n        else if (!Character.isLetterOrDigit(currR)) r--;\n        else {\n            if (Character.toLowerCase(currL) != Character.toLowerCase(currR)) return false;\n            l++; r--;\n        }\n    }\n    return true;\n}"
              },
              "cpp": {
                "bruteForce": "bool isPalindromeBrute(string s) {\n    string clean = \"\";\n    for (char c : s) if (isalnum(c)) clean += tolower(c);\n    string rev = clean;\n    reverse(rev.begin(), rev.end());\n    return clean == rev;\n}",
                "optimal": "bool isPalindromeOptimal(string s) {\n    int l = 0, r = s.size() - 1;\n    while (l < r) {\n        if (!isalnum(s[l])) l++;\n        else if (!isalnum(s[r])) r--;\n        else if (tolower(s[l++]) != tolower(s[r--])) return false;\n    }\n    return true;\n}"
              }
            },
            "edgeCases": [
              {
                "title": "Special Characters Only",
                "description": "String like '..,!'",
                "whyItBreaks": "Loop must skip all characters correctly.",
                "howToFix": "Correctly implement isalnum checks before comparing."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "If s[left] is not alphanumeric, what happens?",
                "options": [
                  "Return False",
                  "Move Left pointer forward",
                  "Move Right pointer backward",
                  "Swap Left and Right"
                ],
                "correctAnswer": "Move Left pointer forward",
                "explanation": "We ignore non-alphanumeric characters by skipping them.",
                "category": "movement"
              }
            ]
          }
        ],
        "recognitionSignals": [
          "Sum pair in sorted data",
          "Cycle detection in Linked Lists",
          "In-place array manipulation",
          "Searching in a two-ended range"
        ],
        "formulaPattern": "left++, right-- (convergence) or slow++, fast++ (speed difference)",
        "commonMistakes": [
          "Not sorting the array for target sum problems",
          "Incorrect termination conditions (off-by-one)",
          "Not skipping duplicates in K-Sum patterns"
        ]
      },
      {
        "id": "sliding_window",
        "title": "Sliding Window",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Efficiently handle contiguous subarray problems by maintaining a dynamic window.",
        "definition": "A technique that converts nested loops into a single loop by maintaining a window that slides over the data.",
        "mentalModel": {
          "analogy": "The Digital Frame",
          "analogyImage": "camera_frame_sliding",
          "realWorldExample": "Taking a panoramic photo or finding the best crop in a video timeline.",
          "coreInsight": "Reusing the overlap! When we slide the window by 1, we don't need to recalculate the sum of the intersection. We just subtract the element leaving and add the element entering.",
          "problemStatement": {
            "definition": "Find the maximum sum of any contiguous subarray of size K in a given array.",
            "returnValue": "The maximum sum value.",
            "constraints": [
              "Subarray must be contiguous",
              "Fixed window size K",
              "Linear time complexity O(N)"
            ]
          },
          "efficiencyComparison": {
            "bruteForce": "O(N × K)",
            "optimal": "O(N)",
            "gain": "85%"
          }
        },
        "whatItIs": "Optimizing subarray queries by maintaining a dynamic window state.",
        "coreInvariant": "The window represents a contiguous subarray. For fixed size, it is always length K. For variable size, it is the largest/smallest subarray satisfying the condition.",
        "timeComplexity": [
          {
            "operation": "Fixed Window Scan",
            "time": "O(N)",
            "space": "O(1)"
          },
          {
            "operation": "Variable Window Search",
            "time": "O(N)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "sliding_window",
        "subPatterns": [
          {
            "id": "fixed_window",
            "title": "Fixed Size Window",
            "description": "Window size K is constant throughout the traversal.",
            "signals": [
              "Subarray of fixed length K",
              "Max/Min/Avg sum of K elements"
            ],
            "invariant": "right - left + 1 == K",
            "formula": "NewSum = OldSum - arr[left-1] + arr[right]",
            "mistakes": [
              "Recomputing sum from scratch inside loop",
              "Incorrectly calculating width as right - left",
              "Off-by-one in window initialization"
            ],
            "edgeCases": [
              {
                "title": "K > Array Length",
                "description": "The window size K is larger than the total elements in the array.",
                "whyItBreaks": "Standard loops might access out of bounds or never execute.",
                "howToFix": "Add early exit: if (k > nums.length) return 0;"
              },
              {
                "title": "K = 0 or K = 1",
                "description": "Minimum possible window sizes.",
                "whyItBreaks": "Logic might subtract from empty window or fail to enter loop.",
                "howToFix": "Ensure constraints handle K >= 1; special case K=1 as a simple pass."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "Array: [2, 5, 1, 8, 2], K=3. Current sum=8 (indices 0-2). After sliding right by one, what is the new sum?",
                "options": [
                  "12",
                  "14",
                  "15",
                  "11"
                ],
                "correctAnswer": "14",
                "explanation": "New sum = OldSum - nums[left] + nums[right+1] = 8 - 2 + 8 = 14.",
                "category": "movement"
              },
              {
                "type": "invariant_id",
                "question": "Which invariant is strictly maintained in a Fixed Window?",
                "options": [
                  "Sum <= Target",
                  "Right - Left + 1 == K",
                  "Distinct Counts <= K",
                  "Left < Right"
                ],
                "correctAnswer": "Right - Left + 1 == K",
                "explanation": "Fixed window size ensures the distance between pointers is always K.",
                "category": "invariant"
              },
              {
                "type": "complexity",
                "question": "What is the time complexity of the Optimal Fixed Window approach?",
                "options": [
                  "O(N*K)",
                  "O(N^2)",
                  "O(N)",
                  "O(K)"
                ],
                "correctAnswer": "O(N)",
                "explanation": "Each element is processed exactly once as it enters and leaves the window.",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def max_sum_brute(nums, k):\n    max_s = 0\n    for i in range(len(nums) - k + 1):\n        curr = 0\n        for j in range(i, i + k):\n            curr += nums[j]\n        max_s = max(max_s, curr)\n    return max_s",
                "optimal": "def max_sum_optimal(nums, k):\n    if k > len(nums): return 0\n    curr = sum(nums[:k])\n    max_s = curr\n    for i in range(len(nums) - k):\n        curr = curr - nums[i] + nums[i + k]\n        max_s = max(max_s, curr)\n    return max_s"
              },
              "javascript": {
                "bruteForce": "function maxSumBrute(nums, k) {\n    let maxS = 0;\n    for (let i = 0; i <= nums.length - k; i++) {\n        let curr = 0;\n        for (let j = i; j < i + k; j++) curr += nums[j];\n        maxS = Math.max(maxS, curr);\n    }\n    return maxS;\n}",
                "optimal": "function maxSumOptimal(nums, k) {\n    if (k > nums.length) return 0;\n    let curr = 0;\n    for (let i = 0; i < k; i++) curr += nums[i];\n    let maxS = curr;\n    for (let i = k; i < nums.length; i++) {\n        curr += nums[i] - nums[i - k];\n        maxS = Math.max(maxS, curr);\n    }\n    return maxS;\n}"
              },
              "java": {
                "bruteForce": "public int maxSumBrute(int[] nums, int k) {\n    int maxS = 0;\n    for (int i = 0; i <= nums.length - k; i++) {\n        int curr = 0;\n        for (int j = i; j < i + k; j++) curr += nums[j];\n        maxS = Math.max(maxS, curr);\n    }\n    return maxS;\n}",
                "optimal": "public int maxSumOptimal(int[] nums, int k) {\n    int curr = 0;\n    for (int i = 0; i < k; i++) curr += nums[i];\n    int maxS = curr;\n    for (int i = k; i < nums.length; i++) {\n        curr += nums[i] - nums[i - k];\n        maxS = Math.max(maxS, curr);\n    }\n    return maxS;\n}"
              },
              "cpp": {
                "bruteForce": "int maxSumBrute(vector<int>& nums, int k) {\n    int maxS = 0;\n    for (int i = 0; i <= nums.size() - k; i++) {\n        int curr = 0;\n        for (int j = i; j < i + k; j++) curr += nums[j];\n        maxS = max(maxS, curr);\n    }\n    return maxS;\n}",
                "optimal": "int maxSumOptimal(vector<int>& nums, int k) {\n    int curr = 0;\n    for (int i = 0; i < k; i++) curr += nums[i];\n    int maxS = curr;\n    for (int i = k; i < nums.size(); i++) {\n        curr += nums[i] - nums[i - k];\n        maxS = max(maxS, curr);\n    }\n    return maxS;\n}"
              }
            }
          },
          {
            "id": "variable_window",
            "title": "Variable Size (Shrinkable)",
            "description": "Window expands until condition is met, then shrinks to optimize.",
            "signals": [
              "Longest/Shortest subarray",
              "Condition: Sum >= S",
              "Distinct characters <= K"
            ],
            "invariant": "Window shrinks from left while condition is satisfied.",
            "formula": "while (valid) { update_result; remove_left; }",
            "mistakes": [
              "Using 'if' instead of 'while' for shrinking",
              "Forgetting to update current state when removing left",
              "Incorrectly returning before processing all windows"
            ],
            "edgeCases": [
              {
                "title": "Condition Never Met",
                "description": "The target sum or condition is impossible to achieve given the input.",
                "whyItBreaks": "The inner while loop never executes, and minLen remains Infinity.",
                "howToFix": "Check if result was updated: return minLen === Infinity ? 0 : minLen;"
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "Variable Window (Min Subarray Sum >= S): Array=[2,3,1,2,4,3], S=7. When right reaches index 4 (value 4), what happens to the left pointer?",
                "options": [
                  "Left stays at 0",
                  "Left stays at 2",
                  "Left moves from 0 up to 2",
                  "Left moves from 1 up to 3"
                ],
                "correctAnswer": "Left moves from 0 up to 2",
                "explanation": "At index 4, sum becomes 2+3+1+2+4=12. While sum >= 7: subtract inner. 12-2=10, 10-3=7, 7-1=6. So left moves to index 3.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def min_len_brute(nums, s):\n    n = len(nums)\n    res = float('inf')\n    for i in range(n):\n        curr = 0\n        for j in range(i, n):\n            curr += nums[j]\n            if curr >= s:\n                res = min(res, j - i + 1)\n                break\n    return 0 if res == float('inf') else res",
                "optimal": "def min_len_optimal(nums, s):\n    l, total, res = 0, 0, float('inf')\n    for r in range(len(nums)):\n        total += nums[r]\n        while total >= s:\n            res = min(res, r - l + 1)\n            total -= nums[l]\n            l += 1\n    return 0 if res == float('inf') else res"
              },
              "javascript": {
                "bruteForce": "function minLenBrute(nums, s) {\n    let res = Infinity;\n    for (let i = 0; i < nums.length; i++) {\n        let curr = 0;\n        for (let j = i; j < nums.length; j++) {\n            curr += nums[j];\n            if (curr >= s) {\n                res = Math.min(res, j - i + 1);\n                break;\n            }\n        }\n    }\n    return res === Infinity ? 0 : res;\n}",
                "optimal": "function minLenOptimal(nums, s) {\n    let l = 0, total = 0, res = Infinity;\n    for (let r = 0; r < nums.length; r++) {\n        total += nums[r];\n        while (total >= s) {\n            res = Math.min(res, r - l + 1);\n            total -= nums[l++];\n        }\n    }\n    return res === Infinity ? 0 : res;\n}"
              },
              "java": {
                "bruteForce": "public int minLenBrute(int[] nums, int s) {\n    int res = Integer.MAX_VALUE;\n    for (int i = 0; i < nums.length; i++) {\n        int curr = 0;\n        for (int j = i; j < nums.length; j++) {\n            curr += nums[j];\n            if (curr >= s) { res = Math.min(res, j - i + 1); break; }\n        }\n    }\n    return res == Integer.MAX_VALUE ? 0 : res;\n}",
                "optimal": "public int minLenOptimal(int[] nums, int s) {\n    int l = 0, total = 0, res = Integer.MAX_VALUE;\n    for (int r = 0; r < nums.length; r++) {\n        total += nums[r];\n        while (total >= s) {\n            res = Math.min(res, r - l + 1);\n            total -= nums[l++];\n        }\n    }\n    return res == Integer.MAX_VALUE ? 0 : res;\n}"
              },
              "cpp": {
                "bruteForce": "int minLenBrute(vector<int>& nums, int s) {\n    int res = INT_MAX;\n    for (int i = 0; i < nums.size(); i++) {\n        int curr = 0;\n        for (int j = i; j < nums.size(); j++) {\n            curr += nums[j];\n            if (curr >= s) { res = min(res, j - i + 1); break; }\n        }\n    }\n    return res == INT_MAX ? 0 : res;\n}",
                "optimal": "int minLenOptimal(vector<int>& nums, int s) {\n    int l = 0, total = 0, res = INT_MAX;\n    for (int r = 0; r < nums.size(); r++) {\n        total += nums[r];\n        while (total >= s) {\n            res = min(res, r - l + 1);\n            total -= nums[l++];\n        }\n    }\n    return res == INT_MAX ? 0 : res;\n}"
              }
            }
          },
          {
            "id": "at_most_k",
            "title": "At Most K Pattern",
            "description": "Find number of subarrays with at most K valid elements.",
            "signals": [
              "Exactly K = AtMost(K) - AtMost(K-1)",
              "Number of subarrays",
              "Distinct elements count"
            ],
            "invariant": "Window maintains AT MOST K constraint.",
            "formula": "count += (right - left + 1)",
            "mistakes": [
              "Incorrectly counting subarrays (formula is length of valid window)",
              "Not handling K=0 case",
              "Missing the subtraction step for 'Exactly K' problems"
            ],
            "edgeCases": [
              {
                "title": "K = 0",
                "description": "Finding subarrays with at most 0 distinct elements.",
                "whyItBreaks": "Standard logic might fail to enter while loop or delete non-existent keys.",
                "howToFix": "Early exit if (k == 0) return 0;"
              }
            ],
            "drills": [
              {
                "type": "count_contribution",
                "question": "If common window is [left, right], how many subarrays ending AT right are added?",
                "options": [
                  "1",
                  "right-left",
                  "right-left+1",
                  "right"
                ],
                "correctAnswer": "right-left+1",
                "explanation": "Every index from left up to right can be a valid start for a subarray ending at right.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def at_most_brute(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        s = set()\n        for j in range(i, len(nums)):\n            s.add(nums[j])\n            if len(s) <= k: count += 1\n            else: break\n    return count",
                "optimal": "def at_most_optimal(nums, k):\n    l, res, counts = 0, 0, {}\n    for r in range(len(nums)):\n        counts[nums[r]] = counts.get(nums[r], 0) + 1\n        while len(counts) > k:\n            counts[nums[l]] -= 1\n            if counts[nums[l]] == 0: del counts[nums[l]]\n            l += 1\n        res += (r - l + 1)\n    return res"
              },
              "javascript": {
                "bruteForce": "function atMostBrute(nums, k) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let s = new Set();\n        for (let j = i; j < nums.length; j++) {\n            s.add(nums[j]);\n            if (s.size <= k) count++;\n            else break;\n        }\n    }\n    return count;\n}",
                "optimal": "function atMostOptimal(nums, k) {\n    let l = 0, res = 0, map = new Map();\n    for (let r = 0; r < nums.length; r++) {\n        map.set(nums[r], (map.get(nums[r]) || 0) + 1);\n        while (map.size > k) {\n            map.set(nums[l], map.get(nums[l]) - 1);\n            if (map.get(nums[l]) === 0) map.delete(nums[l]);\n            l++;\n        }\n        res += (r - l + 1);\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int atMostBrute(int[] nums, int k) {\n    int count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        Set<Integer> s = new HashSet<>();\n        for (int j = i; j < nums.length; j++) {\n            s.add(nums[j]);\n            if (s.size() <= k) count++;\n            else break;\n        }\n    }\n    return count;\n}",
                "optimal": "public int atMostOptimal(int[] nums, int k) {\n    int l = 0, res = 0;\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int r = 0; r < nums.length; r++) {\n        map.put(nums[r], map.getOrDefault(nums[r], 0) + 1);\n        while (map.size() > k) {\n            map.put(nums[l], map.get(nums[l]) - 1);\n            if (map.get(nums[l]) == 0) map.remove(nums[l]);\n            l++;\n        }\n        res += (r - l + 1);\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "int atMostBrute(vector<int>& nums, int k) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        unordered_set<int> s;\n        for (int j = i; j < nums.size(); j++) {\n            s.insert(nums[j]);\n            if (s.size() <= k) count++;\n            else break;\n        }\n    }\n    return count;\n}",
                "optimal": "int atMostOptimal(vector<int>& nums, int k) {\n    int l = 0, res = 0;\n    unordered_map<int, int> mp;\n    for (int r = 0; r < nums.size(); r++) {\n        mp[nums[r]]++;\n        while (mp.size() > k) {\n            if (--mp[nums[l]] == 0) mp.erase(nums[l]);\n            l++;\n        }\n        res += (r - l + 1);\n    }\n    return res;\n}"
              }
            }
          },
          {
            "id": "exact_k",
            "title": "Exact K Strategy",
            "description": "Calculate logic for exactly K by subtracting AtMost(K-1) from AtMost(K).",
            "signals": [
              "Exactly K distinct elements",
              "Exactly K total sum"
            ],
            "invariant": "Exactly(K) = AtMost(K) - AtMost(K-1)",
            "formula": "res = solve(K) - solve(K-1)",
            "mistakes": [
              "Trying to solve 'Exactly K' directly with one loop (leads to complex logic)",
              "Not checking if K=0",
              "Off-by-one in the K-1 call"
            ],
            "edgeCases": [
              {
                "title": "K = 1",
                "description": "Finding subarrays with exactly 1 distinct element.",
                "whyItBreaks": "AtMost(0) would return 0, making result equal to AtMost(1).",
                "howToFix": "Standard Exactly formula handles K=1 correctly as long as AtMost(0) is implemented robustly."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "What is the primary relationship used to solve Exact K problems?",
                "options": [
                  "AtMost(K) + AtMost(K-1)",
                  "AtMost(K) - AtMost(K-1)",
                  "AtMost(K) * 2",
                  "AtMost(K) / 2"
                ],
                "correctAnswer": "AtMost(K) - AtMost(K-1)",
                "explanation": "This identity removes all subarrays with fewer than K elements, leaving only those with exactly K.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def exactly_k_brute(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        s = set()\n        for j in range(i, len(nums)):\n            s.add(nums[j])\n            if len(s) == k: count += 1\n            elif len(s) > k: break\n    return count",
                "optimal": "def exactly_k_optimal(nums, k):\n    return at_most_k(nums, k) - at_most_k(nums, k - 1)"
              },
              "javascript": {
                "bruteForce": "function exactlyKBrute(nums, k) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let s = new Set();\n        for (let j = i; j < nums.length; j++) {\n            s.add(nums[j]);\n            if (s.size === k) count++;\n            else if (s.size > k) break;\n        }\n    }\n    return count;\n}",
                "optimal": "function exactlyKOptimal(nums, k) {\n    return atMostK(nums, k) - atMostK(nums, k - 1);\n}"
              },
              "java": {
                "bruteForce": "public int exactlyKBrute(int[] nums, int k) {\n    int count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        Set<Integer> s = new HashSet<>();\n        for (int j = i; j < nums.length; j++) {\n            s.add(nums[j]);\n            if (s.size() == k) count++;\n            else if (s.size() > k) break;\n        }\n    }\n    return count;\n}",
                "optimal": "public int exactlyKOptimal(int[] nums, int k) {\n    return atMostK(nums, k) - atMostK(nums, k - 1);\n}"
              },
              "cpp": {
                "bruteForce": "int exactlyKBrute(vector<int>& nums, int k) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        unordered_set<int> s;\n        for (int j = i; j < nums.size(); j++) {\n            s.insert(nums[j]);\n            if (s.size() == k) count++;\n            else if (s.size() > k) break;\n        }\n    }\n    return count;\n}",
                "optimal": "int exactlyKOptimal(vector<int>& nums, int k) {\n    return atMostK(nums, k) - atMostK(nums, k - 1);\n}"
              }
            }
          },
          {
            "id": "longest_valid",
            "title": "Longest Valid Window",
            "description": "Find the maximum length r-l+1 where condition holds.",
            "signals": [
              "Max length",
              "Longest substring",
              "Condition constraint"
            ],
            "invariant": "Update result AFTER ensuring window is valid.",
            "formula": "max_len = max(max_len, r - l + 1)",
            "mistakes": [
              "Updating max_len inside the while loop instead of after it",
              "Initial max_len set to 0 vs -1",
              "Off-by-one in length calculation"
            ],
            "edgeCases": [
              {
                "title": "K = 0",
                "description": "Finding longest window with 0 distinct elements.",
                "whyItBreaks": "Loop might not execute or result stays at 0.",
                "howToFix": "Early exit or ensure logic handles empty results."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Longest Valid Window', when is our 'maxLength' updated?",
                "options": [
                  "Whenever right moves",
                  "Inside the while loop as we shrink",
                  "After the while loop ensures the window is valid",
                  "Only at the end of the program"
                ],
                "correctAnswer": "After the while loop ensures the window is valid",
                "explanation": "We only record the length once the current window [left, right] satisfies the constraint.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def longest_brute(s, k):\n    max_l = 0\n    for i in range(len(s)):\n        counts = {}\n        for j in range(i, len(s)):\n            counts[s[j]] = counts.get(s[j], 0) + 1\n            if len(counts) <= k:\n                max_l = max(max_l, j - i + 1)\n            else: break\n    return max_l",
                "optimal": "def longest_optimal(s, k):\n    l, max_l, counts = 0, 0, {}\n    for r in range(len(s)):\n        counts[s[r]] = counts.get(s[r], 0) + 1\n        while len(counts) > k:\n            counts[s[l]] -= 1\n            if counts[s[l]] == 0: del counts[s[l]]\n            l += 1\n        max_l = max(max_l, r - l + 1)\n    return max_l"
              },
              "javascript": {
                "bruteForce": "function longestBrute(s, k) {\n    let maxL = 0;\n    for (let i = 0; i < s.length; i++) {\n        let map = new Map();\n        for (let j = i; j < s.length; j++) {\n            map.set(s[j], (map.get(s[j]) || 0) + 1);\n            if (map.size <= k) maxL = Math.max(maxL, j - i + 1);\n            else break;\n        }\n    }\n    return maxL;\n}",
                "optimal": "function longestOptimal(s, k) {\n    let l = 0, maxL = 0, map = new Map();\n    for (let r = 0; r < s.length; r++) {\n        map.set(s[r], (map.get(s[r]) || 0) + 1);\n        while (map.size > k) {\n            map.set(s[l], map.get(s[l]) - 1);\n            if (map.get(s[l]) === 0) map.delete(s[l]);\n            l++;\n        }\n        maxL = Math.max(maxL, r - l + 1);\n    }\n    return maxL;\n}"
              },
              "java": {
                "bruteForce": "public int longestBrute(String s, int k) {\n    int maxL = 0;\n    for (int i = 0; i < s.length(); i++) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (int j = i; j < s.length(); j++) {\n            char c = s.charAt(j);\n            map.put(c, map.getOrDefault(c, 0) + 1);\n            if (map.size() <= k) maxL = Math.max(maxL, j - i + 1);\n            else break;\n        }\n    }\n    return maxL;\n}",
                "optimal": "public int longestOptimal(String s, int k) {\n    int l = 0, maxL = 0;\n    Map<Character, Integer> map = new HashMap<>();\n    for (int r = 0; r < s.length(); r++) {\n        char c = s.charAt(r);\n        map.put(c, map.getOrDefault(c, 0) + 1);\n        while (map.size() > k) {\n            char leftChar = s.charAt(l);\n            map.put(leftChar, map.get(leftChar) - 1);\n            if (map.get(leftChar) == 0) map.remove(leftChar);\n            l++;\n        }\n        maxL = Math.max(maxL, r - l + 1);\n    }\n    return maxL;\n}"
              },
              "cpp": {
                "bruteForce": "int longestBrute(string s, int k) {\n    int maxL = 0;\n    for (int i = 0; i < s.size(); i++) {\n        unordered_map<char, int> map;\n        for (int j = i; j < s.size(); j++) {\n            map[s[j]]++;\n            if (map.size() <= k) maxL = max(maxL, j - i + 1);\n            else break;\n        }\n    }\n    return maxL;\n}",
                "optimal": "int longestOptimal(string s, int k) {\n    int l = 0, maxL = 0;\n    unordered_map<char, int> map;\n    for (int r = 0; r < s.size(); r++) {\n        map[s[r]]++;\n        while (map.size() > k) {\n            if (--map[s[l]] == 0) map.erase(s[l]);\n            l++;\n        }\n        maxL = max(maxL, r - l + 1);\n    }\n    return maxL;\n}"
              }
            }
          },
          {
            "id": "minimum_valid",
            "title": "Minimum Valid Window",
            "description": "Find the smallest r-l+1 that satisfies the condition.",
            "signals": [
              "Min length",
              "Shortest subarray",
              "Minimum window substring"
            ],
            "invariant": "Shrink until just BEFORE window becomes invalid.",
            "formula": "min_len = min(min_len, r - l + 1)",
            "mistakes": [
              "Not initializing min_len to a large enough value",
              "Failing to return 0/empty string if no solution exists",
              "Wrong shrink condition"
            ],
            "edgeCases": [
              {
                "title": "No solution",
                "description": "The target string 't' contains characters not in 's'.",
                "whyItBreaks": "Result length remains Infinity.",
                "howToFix": "Return empty string if resLen == Infinity."
              }
            ],
            "drills": [
              {
                "type": "complexity",
                "question": "What is the space complexity of Hard Minimum Window Substring using character frequencies?",
                "options": [
                  "O(1) - alphabet size is fixed",
                  "O(N)",
                  "O(T)",
                  "O(N+T)"
                ],
                "correctAnswer": "O(1) - alphabet size is fixed",
                "explanation": "Since there are a finite number of characters (e.g., 256 for ASCII), the frequency map size is bounded.",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def min_window_brute(s, t):\n    from collections import Counter\n    target = Counter(t)\n    res = ''\n    min_l = float('inf')\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            window = Counter(s[i:j+1])\n            if all(window[c] >= target[c] for c in target):\n                if (j - i + 1) < min_l:\n                    min_l = j - i + 1\n                    res = s[i:j+1]\n    return res",
                "optimal": "def min_window_optimal(s, t):\n    from collections import Counter\n    need, have = Counter(t), Counter()\n    l, res, res_len = 0, [-1, -1], float('inf')\n    count, goal = 0, len(need)\n    for r in range(len(s)):\n        c = s[r]\n        have[c] += 1\n        if c in need and have[c] == need[c]: count += 1\n        while count == goal:\n            if (r - l + 1) < res_len:\n                res_len = (r - l + 1)\n                res = [l, r]\n            have[s[l]] -= 1\n            if s[l] in need and have[s[l]] < need[s[l]]: count -= 1\n            l += 1\n    l, r = res\n    return s[l:r+1] if res_len != float('inf') else ''"
              },
              "javascript": {
                "bruteForce": "function minWindowBrute(s, t) {\n    let minL = Infinity, res = '';\n    const isMatch = (win, target) => {\n        for (let char in target) if ((win[char] || 0) < target[char]) return false;\n        return true;\n    };\n    let target = {};\n    for (let c of t) target[c] = (target[c] || 0) + 1;\n    for (let i = 0; i < s.length; i++) {\n        for (let j = i; j < s.length; j++) {\n            let sub = s.substring(i, j+1);\n            let win = {};\n            for (let c of sub) win[c] = (win[c] || 0) + 1;\n            if (isMatch(win, target)) {\n                if (j - i + 1 < minL) {\n                    minL = j - i + 1;\n                    res = sub;\n                }\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "function minWindowOptimal(s, t) {\n    let need = {}, have = {}, l = 0, resLen = Infinity, res = [-1, -1];\n    for (let c of t) need[c] = (need[c] || 0) + 1;\n    let count = 0, goal = Object.keys(need).length;\n    for (let r = 0; r < s.length; r++) {\n        let c = s[r];\n        have[c] = (have[c] || 0) + 1;\n        if (need[c] && have[c] === need[c]) count++;\n        while (count === goal) {\n            if (r - l + 1 < resLen) {\n                resLen = r - l + 1;\n                res = [l, r];\n            }\n            let leftChar = s[l];\n            have[leftChar]--;\n            if (need[leftChar] && have[leftChar] < need[leftChar]) count--;\n            l++;\n        }\n    }\n    return resLen === Infinity ? '' : s.substring(res[0], res[1] + 1);\n}"
              },
              "java": {
                "bruteForce": "public String minWindowBrute(String s, String t) {\n    // Naive O(N^3) implementation for educational comparison\n    String res = \"\";\n    int minL = Integer.MAX_VALUE;\n    for (int i = 0; i < s.length(); i++) {\n        for (int j = i; j < s.length(); j++) {\n            String sub = s.substring(i, j + 1);\n            if (containsAll(sub, t)) {\n                if (sub.length() < minL) {\n                    minL = sub.length();\n                    res = sub;\n                }\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "public String minWindowOptimal(String s, String t) {\n    Map<Character, Integer> need = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    Map<Character, Integer> have = new HashMap<>();\n    int l = 0, count = 0, goal = need.size(), resLen = Integer.MAX_VALUE;\n    int[] res = {-1, -1};\n    for (int r = 0; r < s.length(); r++) {\n        char c = s.charAt(r);\n        have.put(c, have.getOrDefault(c, 0) + 1);\n        if (need.containsKey(c) && have.get(c).equals(need.get(c))) count++;\n        while (count == goal) {\n            if (r - l + 1 < resLen) {\n                resLen = r - l + 1;\n                res[0] = l; res[1] = r;\n            }\n            char leftChar = s.charAt(l);\n            have.put(leftChar, have.get(leftChar) - 1);\n            if (need.containsKey(leftChar) && have.get(leftChar) < need.get(leftChar)) count--;\n            l++;\n        }\n    }\n    return resLen == Integer.MAX_VALUE ? \"\" : s.substring(res[0], res[1] + 1);\n}"
              },
              "cpp": {
                "bruteForce": "string minWindowBrute(string s, string t) {\n    string res = \"\";\n    int minL = INT_MAX;\n    for (int i = 0; i < s.size(); i++) {\n        for (int j = i; j < s.size(); j++) {\n            string sub = s.substr(i, j - i + 1);\n            if (isValid(sub, t)) {\n                if (sub.size() < minL) {\n                    minL = sub.size();\n                    res = sub;\n                }\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "string minWindowOptimal(string s, string t) {\n    unordered_map<char, int> need, have;\n    for (char c : t) need[c]++;\n    int l = 0, count = 0, goal = need.size(), resLen = INT_MAX, resIdx = -1;\n    for (int r = 0; r < s.size(); r++) {\n        char c = s[r];\n        have[c]++;\n        if (need.count(c) && have[c] == need[c]) count++;\n        while (count == goal) {\n            if (r - l + 1 < resLen) {\n                resLen = r - l + 1;\n                resIdx = l;\n            }\n            char leftChar = s[l];\n            if (need.count(leftChar) && have[leftChar] == need[leftChar]) count--;\n            have[leftChar]--;\n            l++;\n        }\n    }\n    return resLen == INT_MAX ? \"\" : s.substr(resIdx, resLen);\n}"
              }
            }
          }
        ],
        "recognitionSignals": [
          "Contiguous subarray/substring tasks",
          "Finding Optimal Range (Max/Min)",
          "Constraint on subarray sum or elements"
        ],
        "formulaPattern": "expand(right); while(invalid) { shrink(left); } updateResult();",
        "commonMistakes": [
          "Not identifying the correct shrink condition",
          "Off-by-one errors in length calculations (r-l+1 vs r-l)",
          "Inefficiently recalculating window state instead of O(1) update"
        ]
      },
      {
        "id": "binary_search",
        "title": "Binary Search",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Divide search space in half at each step to find elements in O(log N).",
        "definition": "The most efficient way to find an item in a sorted collection by repeatedly halving the search space.",
        "mentalModel": {
          "analogy": "The Phone Book Search",
          "analogyImage": "binary_search_analogy",
          "realWorldExample": "Opening a physical book to the middle and moving left or right to find a specific page.",
          "coreInsight": "Sorted data allows us to eliminate 50% of the remaining search space every time we make one comparison.",
          "problemStatement": {
            "definition": "Given a sorted array and a target value, return the index if found, else -1.",
            "returnValue": "Index (Integer) or -1",
            "constraints": [
              "Input MUST be sorted",
              "Access must be O(1) (Random Access)",
              "Time complexity O(log N)"
            ]
          },
          "efficiencyComparison": {
            "bruteForce": "O(N) - Linear Search",
            "optimal": "O(log N)",
            "gain": "99% for large datasets"
          }
        },
        "whatItIs": "An elimination strategy that narrows a range [low, high] until the target is found or the range is empty.",
        "coreInvariant": "The target, if it exists, is always within the current [low, high] bounds.",
        "timeComplexity": [
          {
            "operation": "Search",
            "time": "O(log N)",
            "space": "O(1) Iterative / O(log N) Recursive"
          }
        ],
        "visualizerType": "binary_search",
        "subPatterns": [
          {
            "id": "iterative_standard",
            "title": "Iterative Standard",
            "description": "The memory-efficient implementation using a while loop.",
            "signals": [
              "Find specific element",
              "Sorted array provided",
              "Zero extra space required"
            ],
            "invariant": "low <= high",
            "formula": "mid = low + (high - low) // 2",
            "mistakes": [
              "Using (low+high)/2 (overflow risk)",
              "Infinite loop due to wrong bound adjustment (low=mid instead of low=mid+1)",
              "Wrong condition (low < high misses the last element)"
            ],
            "edgeCases": [
              {
                "title": "Empty Array",
                "description": "Input array has length 0.",
                "whyItBreaks": "Accessing index 0 or r = -1 logic.",
                "howToFix": "Handle length 0 check or ensure loop condition handles l > r immediately."
              },
              {
                "title": "Target Not Found",
                "description": "Target is not in the array.",
                "whyItBreaks": "Loop finishes without returning.",
                "howToFix": "Return -1 after the loop."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "What is the correct while loop condition for standard binary search?",
                "options": [
                  "low < high",
                  "low <= high",
                  "low + 1 < high",
                  "low != high"
                ],
                "correctAnswer": "low <= high",
                "explanation": "We must allow low == high to check the final element of a length-1 search space.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def binary_search_brute(nums, target):\n    # O(N) Linear Search\n    for i in range(len(nums)):\n        if nums[i] == target: return i\n    return -1",
                "optimal": "def binary_search_optimal(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if nums[mid] == target: return mid\n        if nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return -1"
              },
              "javascript": {
                "bruteForce": "function binarySearchBrute(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === target) return i;\n    }\n    return -1;\n}",
                "optimal": "function binarySearchOptimal(nums, target) {\n    let l = 0, r = nums.length - 1;\n    while (l <= r) {\n        let mid = l + Math.floor((r - l) / 2);\n        if (nums[mid] === target) return mid;\n        nums[mid] < target ? l = mid + 1 : r = mid - 1;\n    }\n    return -1;\n}"
              },
              "java": {
                "bruteForce": "public int binarySearchBrute(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] == target) return i;\n    }\n    return -1;\n}",
                "optimal": "public int binarySearchOptimal(int[] nums, int target) {\n    int l = 0, r = nums.length - 1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return -1;\n}"
              },
              "cpp": {
                "bruteForce": "int binarySearchBrute(vector<int>& nums, int target) {\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == target) return i;\n    }\n    return -1;\n}",
                "optimal": "int binarySearchOptimal(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return -1;\n}"
              }
            }
          },
          {
            "id": "recursive_bs",
            "title": "Recursive Implementation",
            "description": "A divide-and-conquer approach using function calls.",
            "signals": [
              "Tree traversals",
              "Divide and conquer structures",
              "Functional programming style"
            ],
            "invariant": "Base case: low > high",
            "formula": "return solve(low, mid-1) or solve(mid+1, high)",
            "edgeCases": [
              {
                "title": "Recursion Depth Limit",
                "description": "Very large N can theoretically cause stack overflow.",
                "whyItBreaks": "Recursion uses stack frames.",
                "howToFix": "Use iterative approach for extremely large inputs or tail call optimization if supported."
              }
            ],
            "drills": [
              {
                "type": "complexity",
                "question": "What is the space complexity of recursive binary search?",
                "options": [
                  "O(1)",
                  "O(log N)",
                  "O(N)",
                  "O(N log N)"
                ],
                "correctAnswer": "O(log N)",
                "explanation": "Each recursive call adds a frame to the stack. Depth is log N.",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def search_brute(nums, target):\n    # Recursion logic for linear search\n    def rec(i):\n        if i >= len(nums): return -1\n        if nums[i] == target: return i\n        return rec(i + 1)\n    return rec(0)",
                "optimal": "def search_optimal(nums, target, l, r):\n    if l > r: return -1\n    mid = l + (r - l) // 2\n    if nums[mid] == target: return mid\n    if nums[mid] < target: return search_optimal(nums, target, mid + 1, r)\n    return search_optimal(nums, target, l, mid - 1)"
              },
              "javascript": {
                "bruteForce": "function searchBrute(nums, target) {\n    const rec = (i) => {\n        if (i >= nums.length) return -1;\n        if (nums[i] === target) return i;\n        return rec(i + 1);\n    };\n    return rec(0);\n}",
                "optimal": "function searchOptimal(nums, target, l, r) {\n    if (l > r) return -1;\n    let mid = l + Math.floor((r - l) / 2);\n    if (nums[mid] === target) return mid;\n    return nums[mid] < target ? searchOptimal(nums, target, mid + 1, r) : searchOptimal(nums, target, l, mid - 1);\n}"
              },
              "java": {
                "bruteForce": "public int searchBrute(int[] nums, int target) {\n    return searchLin(nums, target, 0);\n}\nprivate int searchLin(int[] nums, int target, int i) {\n    if (i >= nums.length) return -1;\n    if (nums[i] == target) return i;\n    return searchLin(nums, target, i + 1);\n}",
                "optimal": "public int searchOptimal(int[] nums, int target, int l, int r) {\n    if (l > r) return -1;\n    int mid = l + (r - l) / 2;\n    if (nums[mid] == target) return mid;\n    if (nums[mid] < target) return searchOptimal(nums, target, mid + 1, r);\n    return searchOptimal(nums, target, l, mid - 1);\n}"
              },
              "cpp": {
                "bruteForce": "int searchBrute(vector<int>& nums, int target, int i = 0) {\n    if (i >= nums.size()) return -1;\n    if (nums[i] == target) return i;\n    return searchBrute(nums, target, i + 1);\n}",
                "optimal": "int searchOptimal(vector<int>& nums, int target, int l, int r) {\n    if (l > r) return -1;\n    int mid = l + (r - l) / 2;\n    if (nums[mid] == target) return mid;\n    if (nums[mid] < target) return searchOptimal(nums, target, mid + 1, r);\n    return searchOptimal(nums, target, l, mid - 1);\n}"
              }
            }
          },
          {
            "id": "find_leftmost",
            "title": "Foundational: Find Leftmost",
            "description": "Find the first occurrence of a duplicate element.",
            "signals": [
              "Duplicates in array",
              "Lower bound search",
              "Insertion index"
            ],
            "invariant": "Shrink right bound even when target is found.",
            "formula": "if (nums[mid] >= target) high = mid else low = mid + 1",
            "edgeCases": [
              {
                "title": "All Elements Same",
                "description": "Array contains only the target value [2, 2, 2].",
                "whyItBreaks": "Standard search stops at the middle.",
                "howToFix": "Continue searching LEFT (high = mid - 1) after finding target."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Find First/Leftmost', if nums[mid] == target, what do we do?",
                "options": [
                  "Return mid",
                  "Move right (low = mid + 1)",
                  "Move left (high = mid - 1)",
                  "Stop"
                ],
                "correctAnswer": "Move left (high = mid - 1)",
                "explanation": "We want the leftmost occurrence, so we record this position but continue checking the left half.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def find_first_brute(nums, target):\n    for i in range(len(nums)):\n        if nums[i] == target: return i\n    return -1",
                "optimal": "def find_first_optimal(nums, target):\n    l, r, res = 0, len(nums) - 1, -1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if nums[mid] == target:\n            res = mid; r = mid - 1\n        elif nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return res"
              },
              "javascript": {
                "bruteForce": "function findFirstBrute(nums, target) {\n    return nums.indexOf(target);\n}",
                "optimal": "function findFirstOptimal(nums, target) {\n    let l = 0, r = nums.length - 1, res = -1;\n    while (l <= r) {\n        let mid = l + Math.floor((r - l) / 2);\n        if (nums[mid] === target) { res = mid; r = mid - 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int findFirstBrute(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) \n        if (nums[i] == target) return i;\n    return -1;\n}",
                "optimal": "public int findFirstOptimal(int[] nums, int target) {\n    int l = 0, r = nums.length - 1, res = -1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) { res = mid; r = mid - 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "int findFirstBrute(vector<int>& nums, int target) {\n    for (int i = 0; i < nums.size(); i++) \n        if (nums[i] == target) return i;\n    return -1;\n}",
                "optimal": "int findFirstOptimal(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1, res = -1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) { res = mid; r = mid - 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              }
            }
          },
          {
            "id": "find_rightmost",
            "title": "Foundational: Find Rightmost",
            "description": "Find the last occurrence of a duplicate element.",
            "signals": [
              "Duplicates in array",
              "Upper bound search",
              "Finding range ends"
            ],
            "invariant": "Shrink left bound even when target is found.",
            "formula": "if (nums[mid] <= target) low = mid + 1 else high = mid - 1",
            "edgeCases": [
              {
                "title": "All Elements Same",
                "description": "Array contains only the target value [2, 2, 2].",
                "whyItBreaks": "Standard search stops at the middle.",
                "howToFix": "Continue searching RIGHT (low = mid + 1) after finding target."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Find Last/Rightmost', if nums[mid] == target, what do we do?",
                "options": [
                  "Return mid",
                  "Move right (low = mid + 1)",
                  "Move left (high = mid - 1)",
                  "Stop"
                ],
                "correctAnswer": "Move right (low = mid + 1)",
                "explanation": "We want the rightmost occurrence, so we record this position but continue checking the right half.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def find_last_brute(nums, target):\n    res = -1\n    for i in range(len(nums)):\n        if nums[i] == target: res = i\n    return res",
                "optimal": "def find_last_optimal(nums, target):\n    l, r, res = 0, len(nums) - 1, -1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if nums[mid] == target:\n            res = mid; l = mid + 1\n        elif nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return res"
              },
              "javascript": {
                "bruteForce": "function findLastBrute(nums, target) {\n    return nums.lastIndexOf(target);\n}",
                "optimal": "function findLastOptimal(nums, target) {\n    let l = 0, r = nums.length - 1, res = -1;\n    while (l <= r) {\n        let mid = l + Math.floor((r - l) / 2);\n        if (nums[mid] === target) { res = mid; l = mid + 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int findLastBrute(int[] nums, int target) {\n    for (int i = nums.length - 1; i >= 0; i--) \n        if (nums[i] == target) return i;\n    return -1;\n}",
                "optimal": "public int findLastOptimal(int[] nums, int target) {\n    int l = 0, r = nums.length - 1, res = -1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) { res = mid; l = mid + 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "int findLastBrute(vector<int>& nums, int target) {\n    for (int i = nums.size() - 1; i >= 0; i--) \n        if (nums[i] == target) return i;\n    return -1;\n}",
                "optimal": "int findLastOptimal(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1, res = -1;\n    while (l <= r) {\n        int mid = l + (r-l) / 2;\n        if (nums[mid] == target) { res = mid; l = mid + 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              }
            }
          }
        ],
        "recognitionSignals": [
          "Input data is sorted",
          "Finding a specific value or range boundary",
          "Logarithmic time O(log N) required",
          "Search space is monotonic"
        ],
        "formulaPattern": "while (L <= R) { mid = L + (R-L)/2; ... }",
        "commonMistakes": [
          "Arithmetic overflow in mid calculation",
          "Infinite loops by not moving boundaries mid + 1 or mid - 1",
          "Confusing 'lower bound' logic with standard search"
        ],
        "edgeCases": [
          {
            "title": "Empty Array",
            "description": "Input array has no elements.",
            "whyItBreaks": "Accessing nums[0] or initialization fails.",
            "howToFix": "Early exit if (nums.length == 0)."
          },
          {
            "title": "Single Element",
            "description": "Array has exactly one element.",
            "whyItBreaks": "Low and High start and end at the same index.",
            "howToFix": "Ensure while condition is (low <= high)."
          }
        ],
        "microDrills": [
          {
            "question": "What is the time complexity of binary search on a sorted array of size N?",
            "options": [
              "O(1)",
              "O(log N)",
              "O(N)",
              "O(N log N)"
            ],
            "correctAnswer": "O(log N)"
          }
        ]
      },
      {
        "id": "monotonic_stack",
        "title": "Monotonic Stack",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Maintain elements in a sorted order within a stack to solve 'Next Greater/Smaller' problems in O(N).",
        "definition": "A stack that maintains its elements in a specific order (increasing or decreasing) by popping elements that violate the order when a new element arrives.",
        "mentalModel": {
          "analogy": "The Line of Sight",
          "analogyImage": "monotonic_stack_analogy",
          "realWorldExample": "Standing in a line and looking forward: you can only see people taller than everyone between you and them.",
          "coreInsight": "Popping elements! When a new element comes, it 'removes' all elements that it 'dominates' (e.g., in Next Greater, a larger value makes previous smaller values irrelevant).",
          "problemStatement": {
            "definition": "For each element in an array, find the first element to its right that is greater than it.",
            "returnValue": "An array of the same size with the next greater values or -1.",
            "constraints": [
              "Linear time complexity O(N)",
              "Each element pushed and popped at most once",
              "Space complexity O(N)"
            ]
          },
          "efficiencyComparison": {
            "bruteForce": "O(N²) - Nested loops checking right",
            "optimal": "O(N)",
            "gain": "90% for sparse results"
          }
        },
        "whatItIs": "A data structure pattern that keeps elements sorted (monotonically) to find nearest neighbors with specific properties.",
        "coreInvariant": "Stack is always sorted. For Monotonic Increasing: Stack[i] < Stack[i+1].",
        "timeComplexity": [
          {
            "operation": "Single Pass Build",
            "time": "O(N)",
            "space": "O(N)"
          }
        ],
        "visualizerType": "monotonic_stack",
        "subPatterns": [
          {
            "id": "next_greater",
            "title": "Next Greater Element",
            "description": "Maintain a Monotonic Decreasing stack to find the first larger value on the right.",
            "signals": [
              "Find next larger",
              "Daily temperatures",
              "Nearest peak"
            ],
            "invariant": "Elements in stack are in decreasing order.",
            "formula": "while (stack and current > stack[-1]) { process(stack.pop()) }",
            "mistakes": [
              "Using increasing stack for Next Greater logic",
              "Stacking values instead of indices (indices are more versatile)",
              "Not initializing the result array with -1"
            ],
            "edgeCases": [
              {
                "title": "Strictly Decreasing Input",
                "description": "Array is sorted descending [5, 4, 3, 2, 1].",
                "whyItBreaks": "No element has a next greater.",
                "howToFix": "Ensure result array is initialized with -1."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "To find the Next GREATER Element, what kind of Monotonic Stack do we need?",
                "options": [
                  "Monotonic Increasing (1, 2, 3)",
                  "Monotonic Decreasing (3, 2, 1)",
                  "Unsorted Stack",
                  "Queue"
                ],
                "correctAnswer": "Monotonic Decreasing (3, 2, 1)",
                "explanation": "We keep smaller elements in the stack waiting for a greater one. A decreasing stack means the top is the smallest 'waiting' candidate.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def next_greater_brute(nums):\n    res = [-1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] > nums[i]:\n                res[i] = nums[j]\n                break\n    return res",
                "optimal": "def next_greater_optimal(nums):\n    res = [-1] * len(nums)\n    stack = []\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            idx = stack.pop()\n            res[idx] = nums[i]\n        stack.append(i)\n    return res"
              },
              "javascript": {
                "bruteForce": "function nextGreaterBrute(nums) {\n    let res = new Array(nums.length).fill(-1);\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[j] > nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "function nextGreaterOptimal(nums) {\n    let res = new Array(nums.length).fill(-1);\n    let stack = [];\n    for (let i = 0; i < nums.length; i++) {\n        while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\n            let idx = stack.pop();\n            res[idx] = nums[i];\n        }\n        stack.push(i);\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int[] nextGreaterBrute(int[] nums) {\n    int[] res = new int[nums.length];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] > nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "public int[] nextGreaterOptimal(int[] nums) {\n    int[] res = new int[nums.length];\n    Arrays.fill(res, -1);\n    Stack<Integer> stack = new Stack<>();\n    for (int i = 0; i < nums.length; i++) {\n        while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {\n            res[stack.pop()] = nums[i];\n        }\n        stack.push(i);\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "vector<int> nextGreaterBrute(vector<int>& nums) {\n    vector<int> res(nums.size(), -1);\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[j] > nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "vector<int> nextGreaterOptimal(vector<int>& nums) {\n    vector<int> res(nums.size(), -1);\n    stack<int> s;\n    for (int i = 0; i < nums.size(); i++) {\n        while (!s.empty() && nums[i] > nums[s.top()]) {\n            res[s.top()] = nums[i];\n            s.pop();\n        }\n        s.push(i);\n    }\n    return res;\n}"
              }
            }
          },
          {
            "id": "next_smaller",
            "title": "Next Smaller Element",
            "description": "Maintain a Monotonic Increasing stack to find the first smaller value on the right.",
            "signals": [
              "Find nearest valley",
              "Smallest element to the right",
              "Histogram boundaries"
            ],
            "invariant": "Elements in stack are in increasing order.",
            "formula": "while (stack and current < stack[-1]) { process(stack.pop()) }",
            "edgeCases": [
              {
                "title": "Strictly Increasing Input",
                "description": "Array is sorted ascending [1, 2, 3, 4, 5].",
                "whyItBreaks": "No element has a next smaller.",
                "howToFix": "Ensure result array is initialized with -1."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "If current element is SMALLER than stack top in Next Smaller problem, what do we do?",
                "options": [
                  "Push current",
                  "Pop top until stack empty or top < current",
                  "Pop top until stack empty or top > current",
                  "Do nothing"
                ],
                "correctAnswer": "Push current",
                "explanation": "Wait! If we want Next SMALLER, we need a MONOTONIC INCREASING stack. If current < top, we violated the increasing order, so we must POP the top because we found its next smaller (the current element).",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def next_smaller_brute(nums):\n    res = [-1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] < nums[i]:\n                res[i] = nums[j]\n                break\n    return res",
                "optimal": "def next_smaller_optimal(nums):\n    res = [-1] * len(nums)\n    stack = []\n    for i in range(len(nums)):\n        while stack and nums[i] < nums[stack[-1]]:\n            idx = stack.pop()\n            res[idx] = nums[i]\n        stack.append(i)\n    return res"
              },
              "javascript": {
                "bruteForce": "function nextSmallerBrute(nums) {\n    let res = new Array(nums.length).fill(-1);\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[j] < nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "function nextSmallerOptimal(nums) {\n    let res = new Array(nums.length).fill(-1);\n    let stack = [];\n    for (let i = 0; i < nums.length; i++) {\n        while (stack.length > 0 && nums[i] < nums[stack[stack.length - 1]]) {\n            res[stack.pop()] = nums[i];\n        }\n        stack.push(i);\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int[] nextSmallerBrute(int[] nums) {\n    int[] res = new int[nums.length];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] < nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "public int[] nextSmallerOptimal(int[] nums) {\n    int[] res = new int[nums.length];\n    Arrays.fill(res, -1);\n    Stack<Integer> s = new Stack<>();\n    for (int i = 0; i < nums.length; i++) {\n        while (!s.isEmpty() && nums[i] < nums[s.peek()]) res[s.pop()] = nums[i];\n        s.push(i);\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "vector<int> nextSmallerBrute(vector<int>& nums) {\n    vector<int> res(nums.size(), -1);\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[j] < nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "vector<int> nextSmallerOptimal(vector<int>& nums) {\n    vector<int> res(nums.size(), -1);\n    stack<int> s;\n    for (int i = 0; i < nums.size(); i++) {\n        while (!s.empty() && nums[i] < nums[s.top()]) {\n            res[s.top()] = nums[i];\n            s.pop();\n        }\n        s.push(i);\n    }\n    return res;\n}"
              }
            }
          }
        ],
        "recognitionSignals": [
          "Needs price/value tracking to the right",
          "Finding nearest smaller or greater elements",
          "Standard O(N) requirement for range queries",
          "In-place processing of elements that violate an order"
        ],
        "formulaPattern": "Stack used to store indices; while (violations) { pop & process; } push current;",
        "commonMistakes": [
          "Confusing Increasing vs Decreasing stack order",
          "Storing values in stack instead of indices (harder to calculate distance)",
          "Not considering duplicates (need > or >=?)"
        ],
        "edgeCases": [
          {
            "title": "Strictly Decreasing/Increasing Input",
            "description": "Input is already in the order the stack wants to maintain.",
            "whyItBreaks": "No elements ever get popped until the end.",
            "howToFix": "Ensure result array is pre-filled with default value (e.g. -1)."
          },
          {
            "title": "Duplicates",
            "description": "Same values appear consecutively.",
            "whyItBreaks": "Determines if the next greater is STRICTLY greater.",
            "howToFix": "Use >= vs > depending on requirement."
          }
        ],
        "microDrills": [
          {
            "question": "In a Monotonic Increasing stack, what happens when we see an element LOWER than the top?",
            "options": [
              "Push it anyway",
              "Pop top until top < current",
              "Ignore the element",
              "Empty the stack"
            ],
            "correctAnswer": "Pop top until top < current"
          }
        ]
      },
      {
        "id": "cyclic_sort",
        "title": "Cyclic Sort",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Sort numbers in range 1 to N in O(N) time with O(1) space.",
        "definition": "A pattern to sort arrays containing numbers in a given range by placing each number at its correct index.",
        "visualizerType": "cyclic_sort",
        "subPatterns": [
          {
            "id": "find_missing",
            "title": "Find Missing Number",
            "description": "Identify the number missing from a range of 1..N.",
            "templates": {
              "python": "def find_missing(nums):\n    i = 0\n    while i < len(nums):\n        j = nums[i]\n        if nums[i] < len(nums) and nums[i] != nums[j]:\n            nums[i], nums[j] = nums[j], nums[i]\n        else: i += 1\n    for k in range(len(nums)):\n        if nums[k] != k: return k\n    return len(nums)",
              "javascript": "function findMissing(nums) {\n    let i = 0;\n    while (i < nums.length) {\n        let j = nums[i];\n        if (nums[i] < nums.length && nums[i] !== nums[j]) [nums[i], nums[j]] = [nums[j], nums[i]];\n        else i++;\n    }\n    for (let k = 0; k < nums.length; k++) if (nums[k] !== k) return k;\n    return nums.length;\n}"
            }
          }
        ]
      },
      {
        "id": "merge_intervals",
        "title": "Merge Intervals",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Handle overlapping time intervals or ranges in O(N log N).",
        "definition": "A pattern to resolve overlaps between intervals by sorting and merging.",
        "visualizerType": "merge_intervals",
        "subPatterns": [
          {
            "id": "standard_merge",
            "title": "Standard Merge",
            "description": "Merge all overlapping intervals into one.",
            "templates": {
              "python": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= res[-1][1]: res[-1][1] = max(res[-1][1], end)\n        else: res.append([start, end])\n    return res"
            }
          }
        ]
      },
      {
        "id": "greedy",
        "title": "Greedy Fundamentals",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Make the local optimal choice at each step to find a global optimum.",
        "definition": "An algorithmic paradigm that builds up a solution piece by piece.",
        "visualizerType": "greedy"
      },
      {
        "id": "recursion",
        "title": "Recursion",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Solve complex problems by breaking them into smaller instances of themselves.",
        "definition": "A method where the solution depends on solutions to smaller instances of the same problem.",
        "visualizerType": "recursion"
      },
      {
        "id": "backtracking",
        "title": "Backtracking",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Incremental search for all (or some) solutions to a computational problem.",
        "definition": "A general algorithm for finding all solutions by abandoning candidates ('backtracking').",
        "visualizerType": "backtracking"
      },
      {
        "id": "bfs",
        "title": "BFS (Layer Order)",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Traverse graphs and trees layer by layer using a Queue.",
        "definition": "An algorithm for searching tree or graph data structures for shortest paths.",
        "visualizerType": "bfs"
      },
      {
        "id": "dfs",
        "title": "DFS (Depth First)",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Explore as far as possible along each branch before backtracking.",
        "definition": "An algorithm for traversing or searching tree or graph data structures.",
        "visualizerType": "dfs"
      },
      {
        "id": "topological_sort",
        "title": "Topological Sort",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Linear ordering of directed graph vertices for dependency management.",
        "definition": "A linear ordering s.t. for every edge u->v, u comes before v.",
        "visualizerType": "topological_sort"
      },
      {
        "id": "union_find",
        "title": "Union Find (DSU)",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Efficiently track and merge disjoint sets in O(α(N)).",
        "definition": "A data structure that tracks elements partitioned into disjoint subsets.",
        "visualizerType": "union_find"
      }
    ]
  },
  {
    "id": "advanced_patterns",
    "title": "Advanced Patterns",
    "description": "Complex strategies for high-performance algorithm design.",
    "icon": "Zap",
    "modules": [
      {
        "id": "dp_1d",
        "title": "Dynamic Programming (1D)",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Optimization via subproblems (1D).",
        "definition": "Solving complex problems by breaking them down into simpler 1D subproblems.",
        "visualizerType": "dp_1d",
        "microDrills": []
      },
      {
        "id": "dp_2d",
        "title": "Dynamic Programming (2D)",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Optimization via subproblems (2D Grid).",
        "definition": "Solving complex problems using a 2D grid/table for subproblems.",
        "visualizerType": "dp_2d",
        "microDrills": []
      },
      {
        "id": "trie",
        "title": "Trie",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Prefix tree for string reTRIEval.",
        "definition": "A tree-like data structure used to store a dynamic set or associative array where the keys are usually strings.",
        "visualizerType": "trie",
        "microDrills": []
      },
      {
        "id": "segment_tree",
        "title": "Segment Tree",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Tree for range queries.",
        "definition": "A tree data structure for storing intervals or segments.",
        "visualizerType": "segment_tree",
        "microDrills": []
      },
      {
        "id": "graph_advanced",
        "title": "Shortest Path & MST",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Dijkstra, Prim, Kruskal.",
        "definition": "Algorithms for finding the shortest path between nodes or the minimum spanning tree.",
        "visualizerType": "graph_advanced",
        "microDrills": []
      },
      {
        "id": "string_matching",
        "title": "String Matching",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "KMP, Rabin-Karp.",
        "definition": "Algorithms to find occurrences of a pattern string within a text.",
        "visualizerType": "string_matching",
        "microDrills": []
      }
    ]
  }
]